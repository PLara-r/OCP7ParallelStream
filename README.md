# OCP7ParallelStream

 Работа с параллельными потоками
В Главе 4 вы узнали, что StreamsAPI поддерживает функциональное программирование в Java 8. Одна из самых мощных функций StreamsAPI -
это встроенная поддержка параллелизма. До сих пор все потоки, с которыми вы работали, были последовательными потоками. A serial stream- это поток,
в котором упорядочены результаты, причем одновременно обрабатывается только одна запись.
A parallel stream- это поток, который способен обрабатывать результаты одновременно, используя несколько потоков. Например, вы можете использовать
параллельный поток и потоковый map()метод для одновременной работы с элементами в потоке, что значительно повышает производительность по сравнению
с обработкой одного элемента за раз.
Использование параллельного потока может изменить не только производительность вашего приложения, но и ожидаемые результаты. Как вы увидите,
некоторые операции также требуют специальной обработки, чтобы иметь возможность обрабатываться параллельно.
По умолчанию количество потоков, доступных в параллельном потоке, связано с количеством доступных процессоров в вашей среде. Чтобы увеличить количество потоков,
вам нужно создать свой собственный класс. 
 Создание параллельных потоков
StreamsAPI был разработан , чтобы сделать создание параллельных потоков довольно легко. Для экзамена вы должны быть знакомы с двумя способами создания параллельного потока.
parallel()    параллельно()
Первый способ создания параллельного потока - из существующего потока. Вы просто вызываете parallel()существующий поток, чтобы преобразовать его в поток,
поддерживающий многопоточную обработку, как показано в следующем коде:
Stream<Integer> stream = Arrays.asList(1,2,3,4,5,6).stream();
Stream<Integer> parallelStream = stream.parallel();
Помните, что parallel()это промежуточная операция, которая работает с исходным потоком.  
parallelStream ()
Второй способ создания параллельного потока - из класса коллекции Java. CollectionИнтерфейс включает в себя метод ,
parallelStream()который может быть вызван в любой коллекции и возвращает параллельный поток. Ниже приведен пересмотренный фрагмент кода, который создает
параллельный поток непосредственно из Listобъекта:
Stream<Integer> parallelStream2 = Arrays.asList(1,2,3,4,5,6).parallelStream();
Мы будем использовать parallelStream()на Collectionобъектах в этом разделе.
StreamИнтерфейс включает в себя метод , isParallel()который может быть использован для тестирования , если экземпляр потока поддерживает параллельную обработку.
Некоторые операции над потоками сохраняют параллельный атрибут, а другие - нет. Так , например, Stream.concat(Stream s1, Stream s2)параллельно , если либо s1или s2параллельно. С другой стороны, flatMap()создает новый поток, который не является параллельным по умолчанию, независимо от того, были ли базовые элементы параллельными. 

1) Параллельная обработка задач
Как вы, возможно, заметили, создание параллельного потока является легкой частью. Интересная часть приходит в использовании этого.
Давайте посмотрим на серийный пример:

Arrays.asList(1,2,3,4,5,6)  
 .stream()  
 .forEach(s -> System.out.print(s+" "));
Как вы думаете, что этот код будет выводиться при выполнении как часть main()метода? Давайте взглянем:
1 2 3 4 5 6
Как и следовало ожидать, результаты упорядочены и предсказуемы, потому что мы используем последовательный поток. Что произойдет, если мы будем использовать параллельный поток?

Arrays.asList(1,2,3,4,5,6) 
  .parallelStream()  
 .forEach(s -> System.out.print(s+" "));
В параллельном потоке forEach()операция применяется одновременно к нескольким элементам потока. Ниже приведены примеры выходных данных этого фрагмента кода:

4 1 6 5 2 3
5 2 1 3 6 4
1 2 6 4 5 3
Как видите, результаты больше не упорядочены и не предсказуемы. Если вы сравните это с более ранними частями главы,
 forEach()операция в параллельном потоке будет эквивалентна отправке нескольких Runnableлямбда-выражений исполнителю пула потоков.forEach
FOREACH Результаты заказа
StreamsAPI , включает в себя альтернативный вариант forEach()операции , называемой forEachOrdered(), что вынуждает параллельный поток для обработки результатов, 
чтобы за счет производительности. Например, взгляните на следующий фрагмент кода:

Arrays.asList(1,2,3,4,5,6) 
  .parallelStream() 
  .forEachOrdered(s -> System.out.print(s+" "));
Как и в нашем начальном примере, результаты выводятся в следующем порядке:
1 2 3 4 5 6
Поскольку мы упорядочили результаты, мы потеряли часть прироста производительности при использовании параллельного потока, так зачем использовать этот метод?
Вы можете вызывать этот метод в разделе вашего приложения, который принимает как последовательные, так и параллельные потоки, и вам нужно убедиться, 
что результаты обрабатываются в определенном порядке. Кроме того, потоковые операции, которые происходят до / после, forEachOrdered()могут по-прежнему улучшать
производительность при использовании параллельного потока.

2)Создание неупорядоченных потоков

Все потоки, с которыми вы работали, по умолчанию считаются упорядоченными. Можно создать неупорядоченный поток из упорядоченного потока, аналогично тому, 
как вы создаете параллельный поток из последовательного потока:
Arrays.asList(1,2,3,4,5,6).stream().unordered();
Этот метод на самом деле не переупорядочивает элементы; он просто сообщает JVM, что если применяется потоковая операция на основе заказа, заказ можно игнорировать. 
Например, при вызове skip(5)неупорядоченного потока будут пропущены любые 5элементы, а не первый, 5требуемый для упорядоченного потока.
Для последовательных потоков использование неупорядоченной версии не имеет никакого эффекта, но на параллельных потоках результаты могут значительно повысить
производительность:
Arrays.asList(1,2,3,4,5,6).stream().unordered().parallel();
Даже если неупорядоченные потоки не будут на экзамене, если вы разрабатываете приложения с параллельными потоками, вы должны знать,
когда применять неупорядоченный поток для повышения производительности. 

3) потенциальные проблемы с потоками.

Deadlock, голодание и livelock - три проблемы с потоками, которые могут возникнуть и привести к тому, что потоки никогда не завершат свою задачу. 
Взаимная блокировка возникает, когда два или более потоков заблокированы навсегда. Истощение происходит, когда одному потоку постоянно отказано в доступе к общему ресурсу.
Livelock - это форма голодания, когда два или более потоков активны, но концептуально заблокированы навсегда. Наконец, условия гонки возникают,
когда два потока выполняются одновременно,
поиск и решение таких проблем часто довольно сложно. 
что приводит к неожиданному результату

